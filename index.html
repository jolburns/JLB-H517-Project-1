<!DOCTYPE html>
<html>
<head>
	<title>Project 1 - John L Burns - Cholera Map</title>
	<script src="https://d3js.org/d3.v3.min.js"></script>
	<style>
    	text { 
			font-family: Arial; 
			font-size: 15px;
		}
		.axis path, .axis line {
			fill: none;
			stroke: black;
			shape-rendering: crispEdges;
		}
		.tick text {
			fill: black;
			font-size: 11px;
		}

		rect {
			stroke: white;
		}
	</style>
</head>
<body>
	<div>
		<table>
			<tr>
				<td>
					<svg id="map" width="600" height="600">
						<text id='label' x='0' y='20'>1854 Broad Street Cholera Outbreak</text>
						<g transform="translate(30,40)"></g>
					</svg>
					<div id="map_tooltip"></div>
				</td>
				<td>
					<div>
						<svg id="micro_death_day_bar" width="0" height="0">
							<text id='label' x='0' y='20'>Days</text>
							<g transform="translate(30,40)"></g>
						</svg>
						</br>
						<svg id="micro_age_bar" width="0" height="0">
							<text id='label' x='0' y='10'>Ages</text>
							<g transform="translate(30,40)"></g>
						</svg>
						</br>
						<svg id="micro_sex_bar" width="0" height="0">
							<text id='label' x='0' y='10'>Sexes</text>
							<g transform="translate(30,40)"></g>
						</svg>
						</br>
						<div id="micro_tooltip" death_bars='null' age_bars='null' sex_bars='null'></div>
					</div>
				</td>
			</tr>
		</table>
	</div></br>
	<svg id="death_day_bar" width="300" height="200">
		<text id='label' x='0' y='20'>Deaths by day</text>
		<g transform="translate(30,40)"></g>
	</svg>
	<div id="death_tooltip" death_bars='null' age_bars='null' sex_bars='null'></div>
	<svg id="age_bar" width="300" height="200">
		<text id='label' x='0' y='20'>Deaths by age group</text>
		<g transform="translate(30,40)"></g>
	</svg>
	<div id="age_tooltip"></div>
	<svg id="sex_bar" width="300" height="200">
		<text id='label' x='0' y='20'>Deaths by sex</text>
		<g transform="translate(30,40)"></g>
	</svg>
	<div id="sex_tooltip"></div>
	
	
	<script>
		//setting up variables for later
		//main map
		var map_width = 600;
		var map_height = 600;
		
		//death date bars
		var ddb_width = 500;
		var ddb_height = 200;
		var ddb_bar_height_max = 140;
		var ddb_bar_height_offset = 30;
		var ddb_bar_width = 10;
		
		//age group bars
		var ab_width = 0;
		var ab_x_offset = 25;
		var ab_height = 200;
		var ab_bar_height_offset = 30;
		var ab_bar_height_max = 140;
		var ab_bar_width = 0;
		
		//sex group bars
		var sb_width = 0;
		var sb_x_offset = 25;
		var sb_height = 260;
		var sb_bar_height_offset = 30;
		var sb_bar_height_max = 200;
		var sb_bar_width = 0;
		
		//micro death date bars
		var mddb_width = 250;
		var mddb_height = 115;
		var mddb_bar_height_max = 65;
		var mddb_bar_height_offset = 25;
		var mddb_bar_width = 5;
		
		//micro age group bars
		var mab_width = 0;
		var mab_x_offset = 15;
		var mab_height = 100;
		var mab_bar_height_offset = 15;
		var mab_bar_height_max = 70;
		var mab_bar_width = 0;
		
		//micro sex group bars
		var msb_width = 0;
		var msb_x_offset = 15;
		var msb_height = 130;
		var msb_bar_height_offset = 15;
		var msb_bar_height_max = 100;
		var msb_bar_width = 0;
		
		//arrays
		var street_start_stop = [];
		var pumps = [];
		var death_days = [];
		var days = [];
		var max_death_day = [0];
		var death_xy_age_sex_date = [];
		
		//select the svgs
		var map_svg = d3.select("#map").attr("width", map_width).attr("height", map_height);
		var death_day_bar_svg = d3.select("#death_day_bar");
		var age_bar_svg = d3.select("#age_bar");
		var sex_bar_svg = d3.select("#sex_bar");
		var micro_death_day_bar_svg = d3.select("#micro_death_day_bar");
		var micro_age_bar_svg = d3.select("#micro_age_bar");
		var micro_sex_bar_svg = d3.select("#micro_sex_bar");
			
		//select the tooltips
		var map_tooltip = d3.select("#map_tooltip");
		var death_tooltip = d3.select("#death_tooltip");
		var age_tooltip = d3.select("#death_tooltip");
		var sex_tooltip = d3.select("#death_tooltip");
		var micro_tooltip = d3.select("#micro_tooltip");
		
		//loading in streets.json and displaying the map
		d3.json('streets.json', function(data) 
		{
			// Loop through all objects
			for (i = 0; i < data.length; i++) 
			{
				for (j = 0; j < data[i].length - 1; j++)
				{
					x1 = parseFloat(data[i][j]['x'])
					y1 = parseFloat(data[i][j]['y'])
					x2 = parseFloat(data[i][j+1]['x'])
					y2 = parseFloat(data[i][j+1]['y'])
					street_start_stop.push([x1+0.06, y1+0.08, x2+0.06, y2+0.08]);
					//street_start_stop.push([x1-0.06, y1-0.08, x2-0.06, y2-0.08]);
				}
			}
			
			//make the empty lines
			var map_lines = map_svg.selectAll('line').data(street_start_stop).enter().append('line');
			
			//functions to fix scaling
			var x_scale = d3.scale.linear().domain([0, d3.max(street_start_stop, function(sss) {return sss[0];})]).range([-50, map_width-100]);
			var y_scale = d3.scale.linear().domain([0, d3.max(street_start_stop, function(sss) {return sss[1];})]).range([map_height-50, 50]);
			
			//set x1/y1 for the lines
			map_lines.attr('x1', function(sss) {return x_scale(sss[0])}).attr('y1', function(sss) {return y_scale(sss[1])});
			//set x2/y2 for the lines
			map_lines.attr('x2', function(sss) {return x_scale(sss[2])}).attr('y2', function(sss) {return y_scale(sss[3])});
			
			//color in the lines
			map_lines.attr('stroke', "black");
		});
		
		
		//loading in pumps.csv and displaying them
		d3.csv("pumps.csv", function(data)
		{
			for(i = 0; i < data.length; i++)
			{
				pumps.push([i, data[i]['x'], data[i]['y']]);
			}
			//console.log(pumps);
			
			//functions to fix scaling
			var x_scale = d3.scale.linear().domain([0, d3.max(pumps, function(p) {return p[1];})]).range([-45, map_width-400]);
			var y_scale = d3.scale.linear().domain([0, d3.max(pumps, function(p) {return p[2];})]).range([map_height-53, 290]);
			
			//make the empty pump icons
			var pump_icons = map_svg.selectAll("circle").data(pumps).enter().append("circle");
			
			//set x/y for pumps
			pump_icons.attr("cx", function(p) {return x_scale(p[1]);}).attr("cy", function(p) {return y_scale(p[2]);}).attr("r", 4);
			
			//color the icons
			pump_icons.attr("fill", "blue");
		});
		
		//loading in deathdays.csv 
		d3.csv("deathdays.csv", function(data)
		{
			for(i = 0; i < data.length; i++)
			{
				death_days.push([i, data[i]['date'], data[i]['deaths']]);
				days.push(data[i]['date']);
				if(data[i]['deaths'] >= max_death_day[0]) {max_death_day[0] = parseInt(data[i]['deaths']);}
			}
			//console.log(death_days);
		});
		
		//loading in deaths_age_sex.csv and displaying them
		d3.csv("deaths_age_sex.csv", function(data)
		{
			for(i = 0; i < data.length; i++)
			{
				//convert gender
				if(data[i]['gender'] == 0){g = 'Male';}
				else{g = 'Female';}
				
				//convert age
				switch (data[i]['age'])
				{
					case '0': age = '0-10'; break;
					case '1': age = '11-20'; break;
					case '2': age = '21-40'; break;
					case '3': age = '41-60'; break;
					case '4': age = '61-80'; break;
					case '5': age = '> 81'; break;
				}
				death_xy_age_sex_date.push([data[i]['x'], data[i]['y'], age, g, 0]);
			}
			
			//assigning the id of the day died to each person
			count = 0;
			for(i = 0; i < death_days.length; i++)
			{
				for(j = 0; j < death_days[i][2]; j++)
				{
					death_xy_age_sex_date[count][4] = death_days[i][0];
					death_xy_age_sex_date[count][5] = death_days[i][1];
					count = count+1;
				}
			}
			//console.log(death_xy_age_sex_date);
			
			//functions to fix scaling
			var x_scale = d3.scale.linear().domain([0, d3.max(pumps, function(p) {return p[1];})]).range([-45, map_width-400]);
			var y_scale = d3.scale.linear().domain([0, d3.max(pumps, function(p) {return p[2];})]).range([map_height-52, 290]);
			
			//make the empty death icons
			var death_icons = map_svg.selectAll('rect').data(death_xy_age_sex_date).enter().append('rect');
			
			//set x/y/date for deaths
			death_icons.attr("x", function(p) {return x_scale(p[0]);})
				.attr("y", function(p) {return y_scale(p[1]);})
				.attr("date", function(p) {return p[5];})
				.attr("sex", function(p) {return p[3];})
				.attr("age", function(p) {return p[2];});
			
			//color and size
			death_icons.attr("width", 5).attr("height", 3).attr("fill", "red");
			
			//function for making bars
			function make_bars(death_info) 
			{
				//clear the charts
				age_bar_svg.selectAll("*:not(#label)").remove();
				sex_bar_svg.selectAll("*:not(#label)").remove();
				death_day_bar_svg.selectAll("*:not(#label)").remove();
				
				//make the deaths by day bar chart
				//array of arrays holding the actual date data
				var date_deaths = [];
				var max_death_day = 0;
				for(i =0; i < days.length; i++)
				{
					count = death_info.filter(function(d) {
						return d[5] == days[i];
					}).length;
					date_deaths.push([i, days[i], count]);
					if(count > max_death_day){max_death_day = count;}
				}
				
				//correct ddb_width
				ddb_width = 10*days.length;
				ddb_x_offset = 25;
				death_day_bar_svg.attr("width", ddb_width+ddb_x_offset).attr("height", ddb_height);
				
				//add axis - help from https://stackoverflow.com/questions/41579560/custom-x-axis-labels-in-d3-bar-charts
				//additional help from https://stackoverflow.com/questions/52026579/how-to-draw-grid-lines-fir-every-ticks
				var ddx = d3.scale.ordinal().domain(days).rangeRoundBands([-12, ddb_width], .005);
				var ddx_axis = d3.svg.axis().scale(ddx).orient("bottom").tickSize(0);
				death_day_bar_svg.append("g").attr("class", "x axis")
					.attr("transform", "translate("+ddb_x_offset+","+(ddb_height-ddb_bar_height_offset)+")").call(ddx_axis)
					.selectAll("text").attr("transform", "rotate(-90)").style("font-size", "7px").style("text-anchor", "end");
				
				var ddy = d3.scale.linear().domain([max_death_day,0]).range([0,ddb_height-2*ddb_bar_height_offset]);
				var ddy_axis = d3.svg.axis().scale(ddy).orient("left").ticks(6).outerTickSize(0).innerTickSize(-ddb_width);
				death_day_bar_svg.append("g").attr("class", "y axis").attr("transform", "translate("+(ddb_x_offset-3)+","+(ddb_bar_height_offset)+")")
					.call(ddy_axis).style("stroke-dasharray", "5 5")
					.selectAll("text").attr("transform", "rotate(0)").style("font-size", "7px").style("text-anchor", "end");
				//console.log(death_days)
				//create the blank rectangles, then give them properties
				var death_bars = death_day_bar_svg.selectAll('rect').data(date_deaths).enter().append('rect');
				death_bars.attr('height', function(dd) {return 1+ (dd[2]/max_death_day)*ddb_bar_height_max;})
					.attr('width', ddb_bar_width).attr('x', function(dd, i) {return i*ddb_bar_width;})
					.attr('y', function(dd) {return ddb_height - ddb_bar_height_offset - 2 - (dd[2]/max_death_day)*ddb_bar_height_max})
					.attr("date", function(dd) {return dd[1];})
					.attr("fill", "red").attr("transform","translate("+ddb_x_offset+",0)");
					
				
				//make the age bars
				//console.log(death_xy_age_sex_date);
				//array of arrays holding the actual age data
				var age_deaths = [['0-10', 0], ['11-20', 0], ['21-40', 0], ['41-60', 0], ['61-80', 0], ['> 81', 0]];
				var ages = [];
				var max_death_age = 0;
				for(i =0; i < age_deaths.length; i++)
				{
					count = death_info.filter(function(d) {
						return d[2] == age_deaths[i][0];
					}).length;
					age_deaths[i][1] = count;
					ages.push(age_deaths[i][0]);
					if(count > max_death_age){max_death_age = count;}
				}
				//console.log(age_deaths);
				
				//Fix width now that we have data
				ab_width = 25*age_deaths.length;
				ab_bar_width = ab_width/age_deaths.length;
				
				//set the chart svg width/height
				age_bar_svg.attr("width", ab_width+ab_x_offset).attr("height", ab_height);
				
				var agex = d3.scale.ordinal().domain(ages).rangeRoundBands([-12, ab_width], .005);
				var agex_axis = d3.svg.axis().scale(agex).orient("bottom").tickSize(0);
				age_bar_svg.append("g").attr("class", "x axis")
					.attr("transform", "translate("+ab_x_offset+","+(ab_height-ab_bar_height_offset)+")").call(agex_axis)
					.selectAll("text").attr("transform", "rotate(-90)").style("font-size", "7px").style("text-anchor", "end");
				
				var agey = d3.scale.linear().domain([max_death_age,0]).range([0,ab_height-2*ab_bar_height_offset]);
				var agey_axis = d3.svg.axis().scale(agey).orient("left").ticks(6).outerTickSize(0).innerTickSize(-ab_width);
				
				age_bar_svg.append("g").attr("class", "y axis").attr("transform", "translate("+(ab_x_offset-3)+","+(ab_bar_height_offset)+")")
					.call(agey_axis).style("stroke-dasharray", "5 5")
					.selectAll("text").attr("transform", "rotate(0)").style("font-size", "7px").style("text-anchor", "end");
				//create the blank rectangles, then give them properties
				var age_bars = age_bar_svg.selectAll('rect').data(age_deaths).enter().append('rect');
				
				age_bars.attr('height', function(dd) {return 1+ (dd[1]/max_death_age)*ab_bar_height_max;})
					.attr('width', ab_bar_width).attr('x', function(dd, i) {return i*ab_bar_width;})
					.attr('y', function(dd) {return ab_height - ab_bar_height_offset - 2 - (dd[1]/max_death_age)*ab_bar_height_max})
					.attr("age", function(dd) {return dd[0];})
					.attr("fill", "red").attr("transform","translate("+ab_x_offset+",0)");
			
			
				//make the sex bars
				//array of arrays holding the actual age data
				var sexes = ['Male','Female'];
				var sex_deaths = [['Male',0],['Female',0]];
				var max_death_sex = 0;
				for(i =0; i < sexes.length; i++)
				{
					count = death_info.filter(function(d) {
						return d[3] == sexes[i];
					}).length;
					sex_deaths[i][1] = count;
					if(count > max_death_sex){max_death_sex = count;}
				}
				//console.log(sex_deaths);
				
				//Fix width now that we have data
				sb_width = 45*sex_deaths.length;
				sb_bar_width = sb_width/sex_deaths.length;
				
				//set the chart svg height/width
				sex_bar_svg.attr("width", sb_width+sb_x_offset).attr("height", sb_height);
				
				var sexx = d3.scale.ordinal().domain(sexes).rangeRoundBands([-12, sb_width], .005);
				var sexx_axis = d3.svg.axis().scale(sexx).orient("bottom").tickSize(0);
				sex_bar_svg.append("g").attr("class", "x axis")
					.attr("transform", "translate("+sb_x_offset+","+(sb_height-sb_bar_height_offset)+")").call(sexx_axis)
					.selectAll("text").attr("transform", "rotate(-90)").style("font-size", "7px").style("text-anchor", "end");
				
				var sexy = d3.scale.linear().domain([max_death_sex,0]).range([0,sb_height-2*sb_bar_height_offset]);
				var sexy_axis = d3.svg.axis().scale(sexy).orient("left").ticks(6).outerTickSize(0).innerTickSize(-sb_width);
				
				sex_bar_svg.append("g").attr("class", "y axis").attr("transform", "translate("+(sb_x_offset-3)+","+(sb_bar_height_offset)+")")
					.call(sexy_axis).style("stroke-dasharray", "5 5")
					.selectAll("text").attr("transform", "rotate(0)").style("font-size", "7px").style("text-anchor", "end");
				//create the blank rectangles, then give them properties
				var sex_bars = sex_bar_svg.selectAll('rect').data(sex_deaths).enter().append('rect');
				
				sex_bars.attr('height', function(dd) {return 1+ (dd[1]/max_death_sex)*sb_bar_height_max;})
					.attr('width', sb_bar_width).attr('x', function(dd, i) {return i*sb_bar_width;})
					.attr('y', function(dd) {return sb_height - sb_bar_height_offset - 2 - (dd[1]/max_death_sex)*sb_bar_height_max})
					.attr("sex", function(dd) {return dd[0];})
					.attr("fill", "red").attr("transform","translate("+sb_x_offset+",0)");
				
			}
			make_bars(death_xy_age_sex_date);
			
			//function for making micro bars
			function make_micro_bars(death_info) 
			{
				//clear the charts
				micro_age_bar_svg.selectAll("*:not(#label)").remove();
				micro_sex_bar_svg.selectAll("*:not(#label)").remove();
				micro_death_day_bar_svg.selectAll("*:not(#label)").remove();
				
				//make the deaths by day bar chart
				//array of arrays holding the actual date data
				var date_deaths = [];
				var max_death_day = 0;
				for(i =0; i < days.length; i++)
				{
					count = death_info.filter(function(d) {
						return d[5] == days[i];
					}).length;
					date_deaths.push([i, days[i], count]);
					if(count > max_death_day){max_death_day = count;}
				}
				
				//correct ddb_width
				mddb_width = 7*days.length;
				mddb_x_offset = 25;
				micro_death_day_bar_svg.attr("width", mddb_width+mddb_x_offset).attr("height", mddb_height);
				
				//add axis - help from https://stackoverflow.com/questions/41579560/custom-x-axis-labels-in-d3-bar-charts
				//additional help from https://stackoverflow.com/questions/52026579/how-to-draw-grid-lines-fir-every-ticks
				var ddx = d3.scale.ordinal().domain(days).rangeRoundBands([-12, mddb_width], .005);
				var ddx_axis = d3.svg.axis().scale(ddx).orient("bottom").tickSize(0);
				micro_death_day_bar_svg.append("g").attr("class", "x axis")
					.attr("transform", "translate("+mddb_x_offset+","+(mddb_height-mddb_bar_height_offset)+")").call(ddx_axis)
					.selectAll("text").attr("transform", "rotate(-90)").style("font-size", "7px").style("text-anchor", "end");
				
				var ddy = d3.scale.linear().domain([max_death_day,0]).range([0,mddb_height-2*mddb_bar_height_offset]);
				var ddy_axis = d3.svg.axis().scale(ddy).orient("left").ticks(6).outerTickSize(0).innerTickSize(-mddb_width);
				micro_death_day_bar_svg.append("g").attr("class", "y axis").attr("transform", "translate("+(mddb_x_offset-3)+","+(mddb_bar_height_offset)+")")
					.call(ddy_axis).style("stroke-dasharray", "5 5")
					.selectAll("text").attr("transform", "rotate(0)").style("font-size", "4px").style("text-anchor", "end");
				//console.log(death_days)
				//create the blank rectangles, then give them properties
				var micro_death_bars = micro_death_day_bar_svg.selectAll('rect').data(date_deaths).enter().append('rect');
				micro_death_bars.attr('height', function(dd) {return 1+ (dd[2]/max_death_day)*mddb_bar_height_max;})
					.attr('width', mddb_bar_width).attr('x', function(dd, i) {return i*mddb_bar_width;})
					.attr('y', function(dd) {return mddb_height - mddb_bar_height_offset - 2 - (dd[2]/max_death_day)*mddb_bar_height_max})
					.attr("date", function(dd) {return dd[1];})
					.attr("fill", "red").attr("transform","translate("+mddb_x_offset+",0)");
				
				//make the age bars
				//console.log(death_xy_age_sex_date);
				//array of arrays holding the actual age data
				var age_deaths = [['0-10', 0], ['11-20', 0], ['21-40', 0], ['41-60', 0], ['61-80', 0], ['> 81', 0]];
				var ages = [];
				var max_death_age = 0;
				for(i =0; i < age_deaths.length; i++)
				{
					count = death_info.filter(function(d) {
						return d[2] == age_deaths[i][0];
					}).length;
					age_deaths[i][1] = count;
					ages.push(age_deaths[i][0]);
					if(count > max_death_age){max_death_age = count;}
				}
				//console.log(age_deaths);
				
				//Fix width now that we have data
				mab_width = 15*age_deaths.length;
				mab_bar_width = mab_width/age_deaths.length;
				
				//set the chart svg width/height
				micro_age_bar_svg.attr("width", mab_width+mab_x_offset).attr("height", mab_height);
				
				var agex = d3.scale.ordinal().domain(ages).rangeRoundBands([-12, mab_width], .005);
				var agex_axis = d3.svg.axis().scale(agex).orient("bottom").tickSize(0);
				micro_age_bar_svg.append("g").attr("class", "x axis")
					.attr("transform", "translate("+mab_x_offset+","+(mab_height-mab_bar_height_offset)+")").call(agex_axis)
					.selectAll("text").attr("transform", "rotate(-90)").style("font-size", "7px").style("text-anchor", "end");
				
				var agey = d3.scale.linear().domain([max_death_age,0]).range([0,mab_height-2*mab_bar_height_offset]);
				var agey_axis = d3.svg.axis().scale(agey).orient("left").ticks(6).outerTickSize(0).innerTickSize(-mab_width);
				
				micro_age_bar_svg.append("g").attr("class", "y axis").attr("transform", "translate("+(mab_x_offset-3)+","+(mab_bar_height_offset)+")")
					.call(agey_axis).style("stroke-dasharray", "5 5")
					.selectAll("text").attr("transform", "rotate(0)").style("font-size", "7px").style("text-anchor", "end");
				//create the blank rectangles, then give them properties
				var micro_age_bars = micro_age_bar_svg.selectAll('rect').data(age_deaths).enter().append('rect');
				
				micro_age_bars.attr('height', function(dd) {return 1+ (dd[1]/max_death_age)*mab_bar_height_max;})
					.attr('width', mab_bar_width).attr('x', function(dd, i) {return i*mab_bar_width;})
					.attr('y', function(dd) {return mab_height - mab_bar_height_offset - 2 - (dd[1]/max_death_age)*mab_bar_height_max})
					.attr("age", function(dd) {return dd[0];})
					.attr("fill", "red").attr("transform","translate("+mab_x_offset+",0)");
			
			
				//make the sex bars
				//array of arrays holding the actual age data
				var sexes = ['Male','Female'];
				var sex_deaths = [['Male',0],['Female',0]];
				var max_death_sex = 0;
				for(i =0; i < sexes.length; i++)
				{
					count = death_info.filter(function(d) {
						return d[3] == sexes[i];
					}).length;
					sex_deaths[i][1] = count;
					if(count > max_death_sex){max_death_sex = count;}
				}
				//console.log(sex_deaths);
				
				
				
				//Fix width now that we have data
				msb_width = 20*sex_deaths.length;
				msb_bar_width = msb_width/sex_deaths.length;
				
				//set the chart svg height/width
				micro_sex_bar_svg.attr("width", msb_width+msb_x_offset).attr("height", msb_height);
				
				var sexx = d3.scale.ordinal().domain(sexes).rangeRoundBands([-12, msb_width], .005);
				var sexx_axis = d3.svg.axis().scale(sexx).orient("bottom").tickSize(0);
				micro_sex_bar_svg.append("g").attr("class", "x axis")
					.attr("transform", "translate("+msb_x_offset+","+(msb_height-msb_bar_height_offset)+")").call(sexx_axis)
					.selectAll("text").attr("transform", "rotate(-90)").style("font-size", "7px").style("text-anchor", "end");
				
				var sexy = d3.scale.linear().domain([max_death_sex,0]).range([0,msb_height-2*msb_bar_height_offset]);
				var sexy_axis = d3.svg.axis().scale(sexy).orient("left").ticks(6).outerTickSize(0).innerTickSize(-msb_width);
				
				micro_sex_bar_svg.append("g").attr("class", "y axis").attr("transform", "translate("+(msb_x_offset-3)+","+(msb_bar_height_offset)+")")
					.call(sexy_axis).style("stroke-dasharray", "5 5")
					.selectAll("text").attr("transform", "rotate(0)").style("font-size", "7px").style("text-anchor", "end");
				//create the blank rectangles, then give them properties
				var micro_sex_bars = micro_sex_bar_svg.selectAll('rect').data(sex_deaths).enter().append('rect');
				
				micro_sex_bars.attr('height', function(dd) {return 1+ (dd[1]/max_death_sex)*msb_bar_height_max;})
					.attr('width', msb_bar_width).attr('x', function(dd, i) {return i*msb_bar_width;})
					.attr('y', function(dd) {return msb_height - msb_bar_height_offset - 2 - (dd[1]/max_death_sex)*msb_bar_height_max})
					.attr("sex", function(dd) {return dd[0];})
					.attr("fill", "red").attr("transform","translate("+msb_x_offset+",0)");
				
				micro_tooltip.text("Total deaths: " + death_info.length);
			}
			
			//select all the bars again
			var death_bars_interact = death_day_bar_svg.selectAll('rect');
			var age_bars_interact = age_bar_svg.selectAll('rect');
			var sex_bars_interact = sex_bar_svg.selectAll('rect');
			
			//function to filter death_info data based on bar chart interactions
			function filter_death_info(temp_death_info)
			{
				//grab the tooltip information
				tt_db = death_tooltip.attr("death_bars");
				tt_ab = death_tooltip.attr("age_bars");
				tt_sb = death_tooltip.attr("sex_bars");
				
				//reset all the death_icons to red
				death_icons.attr("fill", 'red');
				
				//if all the selections are empty, exit
				if(tt_db == 'null' && tt_ab == 'null' && tt_sb == 'null') {
					return false;
				}
				
				//filter for date, set != icons to black
				if (tt_db != 'null') {
					temp_death_info = temp_death_info.filter(function(d) {
						return d[5] == tt_db;
					});
					
					death_icons.filter(function() {
						return d3.select(this).attr("date") != tt_db;
					}).attr("fill", 'black');
				} 
				
				//filter for age, set != icons to black
				if (tt_ab != 'null') {
					temp_death_info = temp_death_info.filter(function(d) {
						return d[2] == tt_ab;
					});
					
					death_icons.filter(function() {
						return d3.select(this).attr("age") != tt_ab;
					}).attr("fill", 'black');
				} 
				
				//filter for sex, set != icons to black
				if (tt_sb != 'null') {
					temp_death_info = temp_death_info.filter(function(d) {
						return d[3] == tt_sb;
					});
					
					death_icons.filter(function() {
						return d3.select(this).attr("sex") != tt_sb;
					}).attr("fill", 'black');
				} 				
				return temp_death_info;
			}
			
			function microreset()
			{
				//remove the elements
				micro_age_bar_svg.selectAll("*:not(#label)").remove();
				micro_sex_bar_svg.selectAll("*:not(#label)").remove();
				micro_death_day_bar_svg.selectAll("*:not(#label)").remove();
				
				//set size to 0
				micro_age_bar_svg.attr("width", 0).attr("height", 0);
				micro_sex_bar_svg.attr("width", 0).attr("height", 0);
				micro_death_day_bar_svg.attr("width", 0).attr("height", 0);
				
				//clear out the text
				micro_tooltip.text("");
			}
			
			//give the death bars mouse click events
			//some help from https://stackoverflow.com/questions/35222285/d3-js-bar-mouseover
			//and https://stackoverflow.com/questions/58701387/d3-js-select-node-element-based-on-attributes-value-using-selectall
			death_bars_interact.on("click", function(d) {
				//get the current state of the chart
				selected_state = death_bars_interact.filter(function() {
					return d3.select(this).attr("date") == d[1];
				}).attr("fill") == 'red';
				unselected_state = death_bars_interact.filter(function() {
					return d3.select(this).attr("date") != d[1];
				}).attr("fill") == 'red';
				
				//if the user clicked the same bar, then reset
				if(selected_state == true && unselected_state == false){
					//reset the death_tooltip
					death_tooltip.text("");
					death_tooltip.attr("death_bars", 'null');
					
					//reset the deathbars
					death_bars_interact.filter(function() {
						return d3.select(this).attr("date") != d[1];
					}).attr("fill", 'red');
					
				} else {
					//change the death_tooltip under the bar chart
					death_tooltip.text(d[1] + " deaths: " + d[2]);
					
					//set the deathbars death_tooltip variable
					death_tooltip.attr("death_bars", d[1]);
					
					//set the deathbars to black/red
					death_bars_interact.filter(function() {
						return d3.select(this).attr("date") != d[1];
					}).attr("fill", 'black');
					
					death_bars_interact.filter(function() {
						return d3.select(this).attr("date") == d[1];
					}).attr("fill", 'red');
					
				}
				
				//make the mini charts
				click_death_info = filter_death_info(death_xy_age_sex_date);
				if(click_death_info) {make_micro_bars(click_death_info);}
				else {microreset();}
			})
			
			//give the age bars mouse click events
			age_bars_interact.on("click", function(d) {
				//get the current state of the chart
				selected_state = age_bars_interact.filter(function() {
					return d3.select(this).attr("age") == d[0];
				}).attr("fill") == 'red';
				unselected_state = age_bars_interact.filter(function() {
					return d3.select(this).attr("age") != d[0];
				}).attr("fill") == 'red';
				
				//if the user clicked the same bar, then reset
				if(selected_state == true && unselected_state == false){
					//reset the death_tooltip
					age_tooltip.text("");
					death_tooltip.attr("age_bars", 'null');
					
					//reset the deathbars
					age_bars_interact.filter(function() {
						return d3.select(this).attr("age") != d[0];
					}).attr("fill", 'red');
					
				} else {
					//change the death_tooltip under the bar chart
					age_tooltip.text(d[0] + " deaths: " + d[1]);
					
					//set the deathbars death_tooltip variable
					death_tooltip.attr("age_bars", d[0]);
					
					//set the deathbars to black/red
					age_bars_interact.filter(function() {
						return d3.select(this).attr("age") != d[0];
					}).attr("fill", 'black');
					
					age_bars_interact.filter(function() {
						return d3.select(this).attr("age") == d[0];
					}).attr("fill", 'red');
					
				}
				
				//make the mini charts
				click_death_info = filter_death_info(death_xy_age_sex_date);
				if(click_death_info) {make_micro_bars(click_death_info);}
				else {microreset();}
			})
			
			//give the sex bars mouse click events
			sex_bars_interact.on("click", function(d) {
				//get the current state of the chart
				selected_state = sex_bars_interact.filter(function() {
					return d3.select(this).attr("sex") == d[0];
				}).attr("fill") == 'red';
				unselected_state = sex_bars_interact.filter(function() {
					return d3.select(this).attr("sex") != d[0];
				}).attr("fill") == 'red';
				
				//if the user clicked the same bar, then reset
				if(selected_state == true && unselected_state == false){
					//reset the death_tooltip
					age_tooltip.text("");
					death_tooltip.attr("sex_bars", 'null');
					
					//reset the deathbars
					sex_bars_interact.filter(function() {
						return d3.select(this).attr("sex") != d[0];
					}).attr("fill", 'red');
					
				} else {
					//change the death_tooltip under the bar chart
					age_tooltip.text(d[0] + " deaths: " + d[1]);
					
					//set the deathbars death_tooltip variable
					death_tooltip.attr("sex_bars", d[0]);
					
					//set the deathbars to black/red
					sex_bars_interact.filter(function() {
						return d3.select(this).attr("sex") != d[0];
					}).attr("fill", 'black');
					
					sex_bars_interact.filter(function() {
						return d3.select(this).attr("sex") == d[0];
					}).attr("fill", 'red');
					
				}
				
				//make the mini charts
				click_death_info = filter_death_info(death_xy_age_sex_date);
				if(click_death_info) {make_micro_bars(click_death_info);}
				else {microreset();}
			})
			
		});
		
		
		
	</script>
</body>


</html>
